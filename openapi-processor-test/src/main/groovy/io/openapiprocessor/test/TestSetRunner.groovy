/*
 * Copyright 2020 https://github.com/openapi-processor/openapi-processor-test
 * PDX-License-Identifier: Apache-2.0
 */

package io.openapiprocessor.test

import com.fasterxml.jackson.databind.DeserializationFeature
import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.databind.PropertyNamingStrategies
import com.fasterxml.jackson.dataformat.yaml.YAMLFactory

import java.nio.file.FileSystem
import java.nio.file.Files
import java.nio.file.Path

import static io.openapiprocessor.test.TestSetRunner.ResolveType.PATH_DIFF
import static io.openapiprocessor.test.TestSetRunner.ResolveType.PATH_GENERATED

/**
 * used to execute test sets.
 *
 * confusing:
 * "expected" represents the files from the "generated" folder of the test case
 * "generated" represents the files generated by the processor
 */
class TestSetRunner {

    enum ResolveType {
        PATH_GENERATED, PATH_DIFF
    }

    TestSet testSet
    FileSupport files

    ObjectMapper mapper

    TestSetRunner(TestSet testSet, FileSupport files) {
        this.testSet = testSet
        this.files = files

        mapper = new ObjectMapper (new YAMLFactory ())
            .configure (DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false)
            .setPropertyNamingStrategy (PropertyNamingStrategies.KEBAB_CASE)
    }

    /**
     * runs test set on the native file system
     *
     * @param targetFolder temp folder
     * @return true on success, false on failure, ie. if there were any differences
     */
    boolean runOnNativeFileSystem (File targetFolder) {
        def source = testSet.name

        def processor = testSet.processor
        def options = [
            parser: testSet.parser,
            apiPath: "resource:/tests/${source}/inputs/${testSet.openapi}",
            targetDir: targetFolder.absolutePath
        ]

        def mappingYaml = files.getResource ("/tests/${source}/inputs/mapping.yaml")
        if(mappingYaml) {
            options.mapping = mappingYaml.text
        } else {
            options.mapping = testSet.defaultOptions
        }
        options.mapping = setMappingModelType(options.mapping)

        when:
        processor.run (options)

        then:
        def mapping = getMapping(options.mapping)

        def packageName = mapping.options["package-name"] as String
        def sourcePath = "/tests/${source}"
        def expectedPath = "${sourcePath}/${testSet.expected}"
        def generatedPath = Path.of (targetFolder.absolutePath).resolve (packageName)

        def expectedFiles = files.getExpectedFiles (sourcePath, testSet.expected)
        def generatedFiles = files.getGeneratedFiles (generatedPath)

        // even if not expected, check that the annotation was generated
        def expectedFilesPlus = expectedFiles + ["support/Generated.java"]

        def expectedFileNames = resolveFileNames(expectedFilesPlus, PATH_GENERATED)
        assert expectedFileNames == generatedFiles

        // compare expected files with the generated files
        def success = true
        expectedFiles.each {
            def expected = "${expectedPath}/${resolveFileName(it, PATH_DIFF)}"
            def generated = generatedPath.resolve (resolveFileName(it, PATH_GENERATED))

            success &= !files.printUnifiedDiff (expected, generated)
        }

        success
    }

    /**
     * runs test set on the given file system
     *
     * @param fs the file system
     * @return true on success, false on failure, ie. if there were any differences
     */
    boolean runOnCustomFileSystem (FileSystem fs) {
        def source = testSet.name

        Path root = Files.createDirectory (fs.getPath ("source"))

        def path = "/tests/${source}"
        files.copy (path, files.collectAbsoluteInputPaths (path), root)

        def outputs = files.collectAbsoluteOutputPaths (path)
        outputs = resolveFileNames(outputs, PATH_DIFF).asList()
        files.copy (path, outputs, root)

        Path api = root.resolve ("inputs/${testSet.openapi}")
        Path target = fs.getPath ('target')

        def processor = testSet.processor
        def options = [
            parser: testSet.parser,
            apiPath: api.toUri ().toURL ().toString (),
            targetDir: target.toUri ().toURL ().toString ()
        ]

        def mappingYaml = root.resolve ('inputs/mapping.yaml')
        if(Files.exists (mappingYaml)) {
            options.mapping = mappingYaml.toUri ().toURL ().text
        } else {
            options.mapping = testSet.defaultOptions
        }
        options.mapping = setMappingModelType(options.mapping)

        when:
        processor.run (options)

        then:
        def mapping = getMapping(options.mapping)

        def packageName = mapping.options["package-name"] as String
        def expectedPath = root.resolve (testSet.expected)
        def generatedPath = target.resolve (packageName)

        def expectedFiles = files.getExpectedFiles (path, testSet.expected)
        def generatedFiles = files.getGeneratedFiles (generatedPath)

        // even if not expected, check that the annotation was generated
        def expectedFilesPlus = expectedFiles + ["support/Generated.java"]

        def expectedFileNames = resolveFileNames(expectedFilesPlus, PATH_GENERATED)
        assert expectedFileNames == generatedFiles

        def success = true
        expectedFiles.each {
            def expected = fs.getPath("${expectedPath}/${resolveFileName(it, PATH_DIFF)}")
            def generated = generatedPath.resolve (resolveFileName(it, PATH_GENERATED))

            success &= !files.printUnifiedDiffFs (expected, generated)
        }

        success
    }

    private String setMappingModelType(String source) {
        def mapping = getMapping(source)
        mapping['options']['model-type'] = testSet.modelType
        return mapper.writeValueAsString(mapping)
    }

    private Map<String, ?> getMapping(String source) {
        mapper.readValue(source, Map<String,?>)
    }

    private SortedSet<String> resolveFileNames(Collection<String> paths, ResolveType type) {
        def result = new TreeSet<String> ()

        paths.each {
            result.add(resolveFileName(it, type))
        }

        result
    }

    private String resolveFileName(String path, ResolveType type) {
        def model = "unset"

        if (type == PATH_GENERATED) {
            model = 'model'

        } else if (type == PATH_DIFF) {
            model = 'model/default'

            if (testSet.modelType == 'record') {
                model = 'model/record'
            }
        }

        def result = path.replaceFirst("<model>", model)
        return result
    }

    private printFsTree(FileSystem fs) {
        Files.walk (fs.getPath("/"))
            .forEach {
                println "${it.toAbsolutePath()}"
            }
    }
}
